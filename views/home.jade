extends layouts/global

block head2
  link(rel='stylesheet' href='http://fonts.googleapis.com/css?family=Rambla:400,700|Source+Sans+Pro:400,600')
  link(rel='stylesheet' href='/stylesheets/monokai_sublime.css')
  script(src='/behaviors/highlight.pack.js')
  script.
    hljs.initHighlightingOnLoad();


mixin chapter(name)
  h2(id="#{name.dasherize()}")=chapter(name)
mixin section(name)
  h3(id="#{name.dasherize()}")=section(name)

block content
  #content
    nav#top
      .wrapper
        h1.logo Borg Documentation
        ul.right
          li
            a(href='https://github.com/mikesmullin/borg') Github
          li.toc
            a(href='#top') Docs
          li
            a(href='#contributing') Contribute
          li
            a(href='https://github.com/mikesmullin/borg/graphs/contributors') Credits
        .clear

    header
      .wrapper
        h2 Borg Documentation (v#{version})
        p
          | This information is designed to make you immediately productive with 
          strong: a(href="https://www.npmjs.com/package/borg") Borg v#{borg_version}
          | .
          br
          | When additional versions are released, previous versions will be linked here.
          br
          | Let&rsquo;s get started!

    article
      .wrapper
        +chapter('Getting Started')
        +section('Install Node.JS')
        p
          | Using 
          a(href="https://github.com/creationix/nvm") NVM 
          |  to install 
          a(href="http://nodejs.org") Node.JS
          |  is recommended.
        pre: code.nohighlight
          | curl https://raw.github.com/creationix/nvm/master/install.sh | sh
          | nvm install #{node_version} # latest stable preferred
          | nvm use #{node_version}
          | nvm alias default #{node_version}

        +section('Install Borg')
        pre: code.nohighlight
          | npm install borg -g

        +section('Generate a New Project')
        pre: code.nohighlight
          | borg init Devops
          | cd Devops/
        p
          | Or, hit the ground running by cloning our 
          a(href="https://github.com/mikesmullin/borg-sample-project")
            | existing sample project
          |  which can produce a web server hosting a mirror of this documentation.

        +section('Explore Help')
        p
          | The 
          code borg
          |  
          strong
            | Command Line Interface (
            a(href="http://en.wikipedia.org/wiki/Command-line_interface") CLI
            | )
          |  contains many commands which are not documented here. That documentation
          | is expected to be accessed directly, beginning with the following command:
        pre: code.nohighlight
          | borg help
        p
          strong(style="color:#999") NOTICE:
          |  Most 
          code borg
          |  CLI commands require your working directory to be the project root.

        +chapter('Cloud Integration')
        p
          | Though abstracted to integrate with any cloud provider,
          | only 
          a(href="http://aws.amazon.com/") Amazon Web Services
          |  integration is implemented at present.

        +section('Amazon Web Services')
        p This integration depends on the AWS CLI utility being installed:
        pre: code.nohighlight
          | cd /tmp
          | wget https://s3.amazonaws.com/aws-cli/awscli-bundle.zip
          | unzip awscli-bundle.zip
          | sudo ./awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
          | aws --version # test
        p and configured:
        pre: code.nohighlight
          | aws configure
          | Access Key ID: your-aws-access-key-id
          | Secret Access Key: your-aws-secret-key
        p
          | For more information, please see:
          br
          a(href="http://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/set-up-ec2-cli-linux.html") Setting Up the Amazon EC2 Command Line Interface Tools


        +chapter('Introduction')
        +section('Vernacular')
        ul
          li
            strong script: 
            | file containing code listing steps to complete orchestration.
            br
            br
          li 
            strong resource: 
            | named function organizing common steps for reuse across multiple scripts; often with the secondary goal of becoming operating system agnostic.
            br
            br
          li 
            strong server: 
            | file containing code defining how remote machines are named and addressed, and which scripts must be applied in order to complete their orchestration.
            br
            br
          li 
            strong attribute: 
            | server variable; representing static data, dynamic runtime calculation functions, or personal preferences/overrides for use by scripts at runtime.
            br
            br
          li 
            strong networks.coffee: 
            | file containing a list of servers and their attributes--as well as the relationship of one server to another in a hierarchy of datacenters, groups, server types, and server instances.
            br
            br
          li 
            strong datacenter: 
            | the outermost unit available for the grouping of reusable server definitions (e.g., one datacenter may contain two or more instances of the same server)
            br
            br
          li 
            strong group: 
            | another layer of organization available for the grouping of servers within datacenters; typically named after the environment and project (e.g., a datacenter may contain a group for the production environment of Project A as well as the staging environment for Project B, both of which contain separate instances of the same type of server)
            br
            br
          li 
            strong borg create: 
            | to provision a new empty remote server via cloud provider apis.
            br
            br
          li 
            strong borg assimilate: 
            | to orchestrate a remote server.
            br
            br
          li 
            strong borg assemble: 
            | to both 
            code create
            |  and then 
            code assimilate
            | .
            br
            br

        +section('Directory structure')
        pre: code.nohighlight
          | attributes/		JSON and CSON files; see 
          a(href="#attributes") Attributes
          |  chapter below
          |   networks.coffee	your datacenter and server hierarchy
          |   memory.json		remembers details from cloud provider api interactions
          | scripts/		your Scripts; see 
          a(href="#scripts") Scripts
          |  chapter below
          |   server/		code defining which Servers use which Scripts
          |   vendor/		third-party Scripts as Git submodules



        +chapter('Attributes')
        p
          | Attribute files are regular 
          a(href="http://coffeescript.org") CoffeeScript
          |  files, appropriately suffixed 
          code .coffee
          | , but some of them might more effectively thought of as 
          strong
            | CoffeeScript Object Notation (
            a(href="https://github.com/bevry/cson") CSON
            | )
          | ; a variation of 
          a(href="http://www.json.org/") JSON
          |  that allows you to, among other things, make use of 
          a(href="http://coffeescript.org/#strings") comments
          | , 
          a(href="http://coffeescript.org/#strings") string interpolation
          | , 
          a(href="http://coffeescript.org/#literals") function values
          | , and conditional logic such as 
          a(href="http://coffeescript.org/#conditionals") ternary
          |  and 
          a(href="http://coffeescript.org/#switch") switch statements
          | . These features make it a more versatile alternative to 
          a(href="http://www.yaml.org/") YAML
          | .
        p
          | It is recommended to take advantage of these features to achieve,
          | as close as possible, the overall goal of 
          strong
            a(href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself") DRY
            |  (Don’t Repeat Yourself)
          |  and readability. Strive to simplify the job of an
          | application maintainer who will only want to look in a single place
          | to change any attribute value generated by the devops scripts.
        p
          | There are times when it is appropriate for an attribute to be 
          | defined in more than one place. Borg knows which value to use 
          | in these cases because it merges attribute files in a 
          a(href="#attribute-precedence") specific order
          |  at runtime. For example, your attribute definitions will 
          | override any defaults provided by third-party submodules. 
        p
          | The resulting attribute values are accessible to all scripts 
          | from within the 
          code
            a(href="#@server-object") @server
          |  object, which is also pretty printed 
          | to the debug log at the beginning of each run.

        +section('Attribute Precedence')
        p
          | Although it may seem straightforward, when making changes its 
          | important to be sure any changes to attribute values won’t be 
          | accidentally overridden. To help illustrate both the various 
          | locations where attributes can be defined, and the order that 
          | they get merged to produce the final result, we’ve assembled 
          | the handy chart below, in order of precedence:
        table
          thead: tr
            th Name, Location, Precedence
            th Description
          tbody
            tr
              td
                p
                  strong#hard-coded-attributes
                    | 1. Hard-coded Attributes
                  br
                  | scripts/*/*.coffee
                  br
                  | scripts/*/templates/*/*.coffee
                  br
                  em (un-overridable precedence)
                p
                  | Always scrutinize whether there are values in
                  | your scripts which would be more useful as attributes
                  | that others can see and modify.
              td
                p
                  strong Purpose:
                  br
                  | Define local variables which remain
                  | private to only one script and its templates.
                p
                  | Calculations, for example, may be based on a combination
                  | of attributes defined elsewhere--such as in a
                  | concatenation operation, or a hashing operation, or any
                  | kind of last-minute reformatting.
                p
                  strong Convention:
                  br
                  | Defining constants or overriding attributes within the
                  | template code itself is discouraged, because its
                  | difficult for other users to change these and remain
                  | compatible with your upstream. The only exception is
                  | when a script author is certain the resulting output is
                  | unlikely to be a desired change.
                p
                  | As it happens, most scripts end up 100% hard-coded as
                  | a convenience for authors in a hurry to get testing and building
                  | servers. However, these aren't useful for sharing publicly
                  | until all values are abstracted as overridable attributes.

            tr
              td
                p
                  strong#cli-attributes
                    | 2. CLI 
                    code --locals=
                    |  Attributes
                  br
                  | Process arg w/ CSON value
                  br
                  em (high precedence)
              td
                p
                  strong Purpose:
                  br
                  | Define short-term instance attribute values unique to this run.
                p
                  strong Convention:
                  br
                  | Commonly these are one-time values that are expected to change
                  | by the end of a successful run.
                p
                  | For example, if a script was expected to change the sshd listen
                  | port, but aborted due to an  error before that step was reached,
                  | you may want to override that setting temporarily until you are
                  | done debugging and retrying.
                  br
                  | (e.g., 
                  code ssh: port:
                  | , 
                  code user:
                  | , 
                  code pass:
                  | , 
                  code key:
                  | )

            tr
              td
                p
                  strong#global-attributes
                    | 3. Global Attributes
                  br
                  | attributes/networks.coffee
                  br
                  | in the 
                  code global:
                  |  key
              td
                p
                  strong Purpose:
                  br
                  | Define long-term instance attribute default values in the most general way possible.
                p
                  strong Convention:
                  br
                  | Rarely useful for global user preferences.
                  br
                  | (e.g., 
                  code ssh: port
                  |  or 
                  code tz:
                  | )

            tr
              td
                p
                  strong#datacenter-attributes
                    | 4. Datacenter Attributes
                  br
                  | attributes/networks.coffee
                  br
                  | in the 
                  code datacenters:
                  |  key
              td
                p
                  strong Purpose:
                  br
                  | Define long-term attribute values per-datacenter,
                  | per-environment, per-group, per-type, and/or per-instance.
                p
                  strong Convention:
                  br
                  | Perhaps the most commonly used area to specify attributes
                  | of any.
                p
                  | Details information specific to an instance, such as 
                  | the AWS AMI, instance size, region id, zone, security group,
                  | as well as information used by scripts, such as
                  | memory settings, the number of instances to create in
                  | each datacenter, and how they are grouped. (e.g., by environment)
                p
                  | Also provides individual scripts with hierarchical graph of
                  | all defined systems in the local and extended network,
                  | represented by the 
                  code @networks
                  |  variable, which is intended to be useful when dynamically
                  | configuring firewall, monitoring, whitelists or other lists
                  | that need to access relational information about servers other
                  | than the one currently assimliating.


            tr
              td
                p
                  strong#server-attributes
                    | 5. Server Attributes
                  br
                  | scripts/servers/*.coffee
                  br
                  | within the exported function 
                  code assimilate: ->
                p
                  | Usually there is at least one of these files for each type
                  | of server.
              td
                p
                  strong Purpose:
                  br
                  | Default attributes unique to servers of one type.
                p
                  | These files also define the order that scripts are 
                  | executed to complete assimilation of the machine.
                p
                  strong Convention:
                  br
                  | For example, a set of attribute values shared by servers 
                  | "web01", "web02", ... "web09"
                  | could all be defined once in a file called 
                  code scripts/servers/web.coffee


            tr
              td
                p
                  strong#script-attributes
                    | 6. Script Attributes
                  br
                  | scripts/*/attributes/*/*.coffee
              td
                p
                  strong Purpose:
                  br
                  | The most appropriate place for a script author to declare
                  | all script attributes and set default values which can
                  | be later overridden, because it is packaged together with
                  | the script when shared.
                p
                  | Also the best place to look first for a list of attributes
                  | you can override if you are a new user of a third-party
                  | script.
                p
                  strong Convention:
                  br
                  | It is recommended to define defaults for all script
                  | attributes so the user only has to define overriding values
                  | to address unusual cases.


            tr
              td
                p
                  strong#memory-attributes
                    | 7. Memory Attributes
                  br
                  | attributes/memory.json
                  br
                  em (lowest precedence)
                p
                  | Users should avoid modifying this file directly.
              td
                p
                  strong Purpose:
                  br
                  | Data remembered by Borg after successfully interacting with 
                  | the cloud provider API.
                p
                  strong Convention:
                  br
                  | Great for things you don’t want to have to constantly insert
                  | into an attribute file manually; things Borg can figure out
                  | on its own, or that can only be figured out during/after a
                  | run.
                p
                  | These are commonly used when automatically 
                  | connecting to a newly made server, or deleting an existing 
                  | server.
                  br
                  | (e.g., 
                  code @server.instance_id
                  | , 
                  code @server.public_ip
                  | )

        +section('Cascading Attributes')
        p
          | This next section applies specifically only to the 
          code ./attributes/networks.coffee
          |  file. The goal with this file is to create an object hierarchy like: 
          code datacenters: D1: groups: G1: servers: S1: instances: I1: PROPERTY: VALUE
          |  where ALL-CAPS keys are names you would invent.
          | This hierarchy of 
          strong cascading attributes
          |  (like 
          a(href="https://developer.mozilla.org/en-US/docs/Web/CSS") cascading style sheets
          | )
          | allow the most generic definitions at the root (least 
          a(href="http://www.smashingmagazine.com/2007/07/27/css-specificity-things-you-should-know/") specificity
          | )
          | to be inherited all the way down to the most specific definitions in
          | the deepest leaves (most specificity; in this case, 
          code I1
          | ) to define the network.
        p
          | Observe how the keys are then inherited by instances 
          | through a 
          a(href="https://lodash.com/docs#merge")
            code _.merge()
          |  to create the final fully-detailed 
          | instance-level leaves a.k.a. the final object representing all 
          | the keys attributed to a specific server instance. In order of 
          | objects merged; latter overrides former.
        ol
          li: code global.*
          li
            code datacenters.*.*
            |  (except key: 
            code groups
            | )
          li
            code datacenters.*.groups.*.*
            |  (except key: 
            code servers
            | )
          li
            code datacenters.*.groups.*.servers.*.*
            |  (except key: 
            code instances
            | )
          li
            code datacenters.*.groups.*.servers.*.instances.*.*

        +section('@networks object')
        p
          | A 
          code networks.coffee
          |  structure like:
        pre: code.cson
          | global:
          |   ssh_port: 3562
          | datacenters:
          |   aws-ca:
          |     provider: 'aws'
          |     groups:
          |       'prod-myproject':
          |          env: 'prod'
          |          tld: '.myproject.tld'
          |          servers:
          |            'myapp':
          |              aws_size: 't2.micro'
          |              instances:
          |                '01':
          |                  aws_size: 'm3.xlarge'
          |                  secondary_ip: '1.2.3.4'
          |                '02':
          |                  secondary_ip: '1.2.3.5'

        p
          | Will be merged into a 
          code @networks
          |  object, in scope from within scripts:
        pre: code.cson
          | @networks.datacenters['aws-ca'].groups['prod-myproject'].servers['my-app'].instances['01'] =
          |   aws_size: 'm3.xlarge'
          |   secondary_ip: '1.2.3.4'
          |   env: 'prod'
          |   tld: '.myproject.tld'
          |   provider: 'aws'
          |   ssh_port: 3562

          | @networks.datacenters['aws-ca'].groups['prod-myproject'].servers['my-app'].instances['02'] =
          |   aws_size: 't2.micro'
          |   secondary_ip: '1.2.3.5'
          |   env: 'prod'
          |   tld: '.myproject.tld'
          |   provider: 'aws'
          |   ssh_port: 3562

        p
          | So our script can now reach attributes for all servers, and it can
          | lookup attributes by their relationship to other servers in the
          | network hierarchy. (e.g., what is the secondary_ip of each my-app
          | server in the same datacenter and group as the current server?)

        +section('@server object')
        p
          | But there is also a shortcut to the current server’s attributes--
          | which in the above case, if we pretend the current server is my-app02, 
          | would be:
        pre: code.cson
          | @server =
          |   aws_size: 't2.micro'
          |   secondary_ip: '1.2.3.5'
          |   env: 'prod'
          |   tld: '.myproject.tld'
          |   provider: 'aws'
          |   ssh_port: 3562


        +section('Attribute Functions')
        p
          | Notice you can define function values which are [re-]evaluated
          | (as a 
          a(href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get")
            | javascript getter
          | )
          | at runtime every time they are referenced,
          | and have access to the 
          code @server
          |  object within the function.
        p
          | For example, we can use this to 
          | dynamically reference other attributes, like so:
        pre: code.coffee
          | global:
          |   aws_security_groups: -> [ @server.env +’-’+ @server.type ]
        p
          | We love that we can take this type of data-as-code approach, 
          | and its one of the most compelling
          | reasons why we prefer a javascript-based devops solution.

        +section('Calculated Attributes')
        p
          | Finally, some attributes are calculated and appended for you by 
          | Borg at runtime, even though you didn’t specify them anywhere. 
          | These can be based on parts of the server name 
          | (e.g., 
          code @server.type
          | , 
          code @server.id
          | , 
          code @server.subproject
          | , 
          code @server.env
          | , 
          code @server.tld
          | , 
          code @server.fqdn
          | ) or position in the hierarchy (e.g., 
          code @server.datacenter
          | , 
          code @server.group
          | ).


        +chapter('Resources')
        p
          | All resources are just 
          em
            a(href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function") functions
          | .
          | Within every script and callback--anyplace that would typically
          | be considered a space the average devops scripter would occupy,
          | there is a carefully crafted object provided as the reference
          | of 
          code
            a(href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this") this
          |  in Javascript or 
          code
            a(href="http://coffeescript.org/#operators") @
          |  in CoffeeScript. It is where the 
          code
            a(href="#@server-object") @server
          |  object lives, and it is also where all resources can be found.
        p
          | Borg's resources are divided into three categories:
        ul
          li
            strong
              a(href="#scripts") Core Resources
              | :
            |  Resources referenced by Borg core itself;
            | these are shipped with and are inseparable from Borg.
            | They can generally be considered part of the 
            strong
              | Domain Specific Language (
              a(href="http://en.wikipedia.org/wiki/Domain-specific_language")
                | DSL
              | )
            |  which all scripts use. There are deliberately as few as
            | possible defined.
            br
            br
          li
            strong
              a(href="#common-resources") Common Resources
              | :
            |  Resources most people expect to be there, but aren't needed by Borg core;
            | these are packaged externally like a third-party resource, and installed as a Git submodule by 
            code borg init
            |  with all new projects. That is so anyone who might decide one of its
            | resources isn't good enough for them can replace, modify, or override it.
            br
            br
          li
            strong
              a(href="#third-party-resources") Third-Party Resources
              | :
            |  Resources which clearly wouldn't be used by every project;
            | these are packaged externally and installed as 
            a(href="http://git-scm.com/book/en/v2/Git-Tools-Submodules")
              Git submodules
            |  by 
            code borg install
            |  as-needed. That is so anyone can author a set of resources and share 
            | with others as easily as uploading to 
            a(href="http://github.com") Github.com
            | .
        p
          | Each of these are discussed further in their own separate chapters below.


        +chapter('Scripts')
        p
          | Writing scripts that define 
          em how you want your servers built
          |  is the whole purpose of Borg, and every other feature is only a facilitator
          | toward that goal. The focus surrounds complete control and convenience--
          | for a 
          em: a(href="http://i.imgur.com/dBNfqlQ.jpg") programmer
          | ; someone who dreams in code and works in shells every day.

        +section('Defining Servers')
        p
          | A server definition links your scripts and your 
          a(href="#datacenter-attributes") datacenter attributes
          |  to
          | a single 
          strong
            | Fully Qualified Domain Name (
            a(href="https://kb.iu.edu/d/aiuv") FQDN
            | )
          |  which you can use on the CLI,
          | according to the custom naming convention below.

        p: strong FQDN Format:
        pre: code.nohighlight
          | [
          a(href="#fqdn-datacenter") datacenter
          | ]-[
          a(href="#fqdn-env") env
          | ]-[
          a(href="#fqdn-type") type
          | ][
          a(href="#fqdn-instance") instance
          | ]-[
          a(href="#fqdn-subproject") subproject
          | ].[
          a(href="#fqdn-tld") tld
          | ]
        p: strong Definitions:
        ul
          li
            strong#fqdn-datacenter datacenter:
            |  Must uniquely match a key you define inside the 
            code datacenters:
            |  key.
            br
            | (e.g., 
            code aws-ca
            |  might signify the Amazon Web Services datacenter in California)
            br
            br
          li
            strong#fqdn-env env:
            |  Must match an
            code env:
            |  key value you define.
            br
            | Unique match determined by 
            code datacenter
            | +
            code env
            | . 
            br
            | (e.g., 
            code dev
            | , 
            code stage
            | , 
            code prod
            |  are recommended)
            br
            br
          li
            strong#fqdn-type type:
            |  Must match a key you define inside a 
            code servers:
            |  key.
            br
            | Unique match determined by 
            code datacenter
            | +
            code env
            | +
            code type
            | . 
            br
            | (e.g., 
            code web
            |  might represent horizontally scaling servers hosting your website)
            br
            br
          li
            strong#fqdn-instance instance:
            |  Must match a key you define inside an 
            code instances:
            |  key.
            br
            | Unique match determined by 
            code datacenter
            | +
            code env
            | +
            code type
            | +
            code instance
            | . 
            br
            | (e.g., 
            code 01
            |  might represent the first instance of many more servers like it)
            br
            br
          li
            strong#fqdn-subproject subproject
            |  (Optional):
            |  Must match a 
            code subproject:
            |  key value you define anywhere below the 
            code datacenters:
            |  key. 
            br
            | Unique match determined by 
            code datacenter
            | +
            code subproject
            | . 
            br
            | (e.g., 
            code mobile
            |  might represent the mobile counterpart to your desktop product,
            | if the architecture were significantly different)
            br
            br
          li
            strong#fqdn-tld tld:
            |  (Optional):
            |  Must match a 
            code tld:
            |  key value you define anywhere below the 
            code datacenters:
            |  or 
            code globals:
            |  keys. 
            | Does not have to be unique.
            br
            | (e.g., 
            code .example.org
            |  might be your corporate domain)
        p
          | All definitions of valid values for your project happen inside the 
          code: a(href="#@networks-object") networks.coffee
          |  file.
        p
          | The motivation is to simplify
          | command-line interactions so:
        ol
          li Commands remain simple.
          li Complicated logic connecting everything together remains in code where it belongs.
          li
            p(style="margin-top: 0")
              | Borg can guess your intentions when naming previously undefined new servers,
              | and do the right thing. For example, if all you have defined is:
            pre: code.cson
              | datacenters:
              |   'aws-ca':
              |     tld: '.example.org'
              |     groups:
              |       'mikes-dev':
              |          env: 'dev'
            p
              |  and a 
              code scripts/servers/web.coffee
              |  server definition, Borg will only pause briefly to prompt for 
              | human confirmation that you mean
              | to permanently define new servers (via 
              code: a(href="#memory-attributes") memory.json
              | ) when you specify commands like:
            pre: code.nohighlight
              | borg create aws-ca-dev-web01.example.org
              | borg assimilate aws-ca-dev-web02.example.org
              | borg assemble aws-ca-dev-web99.example.org
            p
              | ...and carry on to do exactly what you had intended. Any further
              | commands referencing those FQDN will be treated exactly as any
              | other pre-defined server, since they are remembered by Borg until 
              code borg destroy
              |  is called, or they are otherwise deleted from 
              code memory.json
              | .


        p
          | The basic server definition looks like this:
        pre: code.coffee
          | # scripts/servers/web.coffee
          | module.exports =
          |   target: ->
          |     @server.type is 'web'

          |   assimilate: ->
          |     @import @cwd, 'scripts', 'web'
        p
          | The callback function 
          code target: ->
          |  is expected to return a 
          a(href="http://en.wikipedia.org/wiki/Boolean_data_type") boolean
          |  determining whether the current 
          code @server
          |  object matches this server definition. Since this is CoffeeScript,
          | all statements are expressions, and the last expression of any function
          | is always returned, unless otherwise specified. So that's exactly
          | what this example does.
        p
          strong(style="color:#999") NOTICE:
          |  Borg will only process the first match found in 
          code scripts/servers/*.coffee
          |  .
        p
          | When a match is found, the next callback function 
          code assimilate: ->
          |  is executed. From there it is up to you to specify
          | any commands or 
          code @import
          |  declarations that act upon the remote server to
          | complete orchestration.




        +section('Importing Code')
        p
          | The import declaration takes arguments similarly to 
          code
            a(href="http://nodejs.org/api/path.html#path_path_join_path1_path2")
              | path.join()
          | . The 
          code @cwd
          |  variable is a string provided by Borg holding the result of 
          code
            a(href="http://nodejs.org/api/process.html#process_process_cwd") process.cwd()
          |  which is expected to be the absolute path to the root of your
          | Borg project.
        pre: code.coffee
          |   @import @cwd, 'scripts', 'vendor', 'redis', 'server'
        p
          | This will 
          code: a(href="http://nodejs.org/api/modules.html") require()
          |  a script located at 
          code scripts/vendor/redis/server.coffee
          | , which in this case can be expected to be provided by a third-party 
          | resource named 
          code: a(href="https://github.com/borg-scripts/redis/blob/master/server.coffee") redis
          | . For example, if someone had run the CLI command:
          pre: code.nohighlight
            | borg install redis
        p
          | ...at some point in the project's history.
        p
          strong(style="color:#999") NOTICE:
          |  Its important to use 
          code @cwd
          |  because it can point to other projects if Borg is 
          | being loaded as a library inside of another application.
        p
          strong(style="color:#999") NOTICE: 
          code @import
          |  is what actually overrides the scope of 
          code this
          |  or 
          code @
          |  for the module.

        +section('Asynchronous Flow Control')
        p
          | There are a lot of ways to do this, but we like 
          strong
            | Continuation-Passing Style (
            a(href="http://matt.might.net/articles/by-example-continuation-passing-style/") CPS
            | )
          | . One well-known caveat to using this approach is remembering that all 
          a(href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Statements")
            | Javascript flow-control statements
          | --such as
          code if
          | , 
          code else
          | , 
          code try
          | , 
          code catch
          | , etc.--don't normally apply.
        p
          | The popular solution is to select 
          a(href="https://github.com/caolan/async") a
          |  
          a(href="https://www.npmjs.com/package/promise") third
          | -
          a(href="https://www.npmjs.com/package/q") party
          |  
          a(href="https://github.com/mikesmullin/async2") library
          |  providing
          | the equivalent behavior as a set of user-defined functions. Borg provides
          | its own set of functions for this purpose.
        p
          | From the 
          strong script developer
          |  perspective, all you need to know is 
          code @then()
          | ; you can think of it as an alias for 
          code: a(href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push")
            | Array::push()
          |  on an array holding a list of your functions
          | which will be executed in-order, all-at-once, later
          | after all scripts have been processed.
        p
          | For example:
        pre: code.coffee
          | @then (cb) =>
          |   console.log "This won't be executed until later."
          |   cb()
        p
          | Except--instead of passing an anonymous function you've just defined--most
          | of the time you are passing strings into predefined resource functions
          | which do the heavy lifting, and hide the passing of callbacks behind an 
          | alluringly simple syntax. Your scripts look more like this:
        pre: code.coffee
          | @then @log "This won't be executed until later."
        p
          | Which means, from the 
          strong resource developer
          |  perspective, your resource functions are defined with a compatible signature, like this:
        pre: code.coffee
          | module.exports = -> 
          a(href="https://lodash.com/docs#assign") _.assign
          |  @,
          |  some_resource: (names, [o]...) => (cb) =>
          |    # your code here
          |    cb()
        p
          | Actually, most times you want to continue using async flows inside your
          | resource. For that we have 
          code @inject_flow()
          |  which looks like this:
        pre: code.coffee
          | module.exports = -> _.assign @,
          |  sync_clock: (names, [o]...) => @inject_flow =>
          |    @then 
          a(href="#@execute()") @execute
          |  "sudo ntpdate -s time.nist.gov"
          |    # no callback hell pyramids here
        p
          | There are three major reasons why we require asynchronous control flow
          | to get anything done in Borg, versus a DSL that is strictly blocking,
          | or simply pasting one long bash script in a string block for that matter.
        ol
          li
            | Its critical to the extensibility and dynamism of the attribute system
            | that we have a two-pass system of script evaluation. The first pass
            | being the one defining attributes and enqueuing functions to the 
            a(href="http://strongloop.com/strongblog/node-js-event-loop/") giant
            |  
            a(href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/") event loop
            |  
            a(href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/") in
            |  
            a(href="http://stackoverflow.com/questions/19822668/what-exactly-is-a-node-js-event-loop-tick") the
            |  
            a(href="http://chimera.labs.oreilly.com/books/1234000001808/ch03.html#chap3_id35941348") sky
            | . The second pass being the one actually performing actions on the
            | remote server during orchestration--possibly re-evaluating
            | attributes since the first pass, in reaction to a server response,
            | or another script.
            br
            br
          li
            | Eventually, your script could be super-parallelized; like multiple
            | SSH connections to one remote server, performing complimentary
            | steps at the same time. Admittedly this application
            | has yet to be demonstrated.
            br
            br
          li
            | Some resources might actually be using functions that are asynchronous
            | even though your script code may not.
        p
          | There are more resources related to async that might become
          | useful as you get further along. You can find them by reviewing
          | examples in the common 
          code: a(href="https://github.com/borg-scripts/resources/blob/master/index.coffee") resources
          |  resource, and in 
          code: a(href="https://github.com/mikesmullin/borg/blob/master/Borg.coffee") Borg.coffee
          | .

        +section('Cryptography')
        p
          | You are encouraged to use the following resources
          |  to obfuscate strings in your project repository.
          | Its a smart thing to do with sensitive information,
          | which would then be relatively safe even if your
          | devops scripts were accidentally leaked.
        pre: code.coffee
          | @then @die @encrypt "example utf8 string"
          | decrypted_string = @decrypt "example base64 string"
        p
          | The cipher is OpenSSL 
          a(href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard") AES-256-CBC
          | . The key is derived
          | from a file in your project root named 
          code ./secret
          |  which typically contains a random 512-byte base64 string
          | generated by 
          code borg init
          |  when your project is first initialized. This file
          | should never be shared in the same way the project
          | source is, or the encryption is useless.
        p
          | Likewise, you can also encrypt binary data files
          | your scripts are expected to upload to remote servers,
          | such as individualized software licenses, using the Borg CLI:
        pre: code.nohighlight
          | borg encrypt # see help
        p
          | and then passing the
          code decrypt: true
          |  option when using resources like 
          code @upload()
          |  to transmit the local file to its remote location on the server.

        +section('Console Debugging')
        p
          | Some people prefer to temporarily sprinkle log
          | statements throughout their code and then run it to see
          | what order they appear on the console log:
        pre: code.coffee
          | @then @log "Reaching here? Let's see what variable x is: \#{x}."
          | console.log() # the non-async way
        p
          | Sometimes also aborting just after the point of interest,
          | to prevent going too far or taking a long time between
          | iterations:
        pre: code.coffee
          | @then @die "I am debugging. This is only temporary."
          | process.exit 1 # the non-async way
        p
          | Its a valid strategy and occasionally faster than other methods.

        +section('Interactive Debugging')
        p
          | You can execute any 
          code borg
          |  CLI command with 
          code debug
          |  as the first parameter to launch a 
          a(href="http://www.google.com/chrome/") Chrome
          |  browser using 
          a(href="https://developer.chrome.com/devtools") DevTools
          |  . This will let you set and catch 
          code debugger
          |  breakpoints, pause, step over,
          | step into, step out, continue, and inspect stack, backtrace, 
          | variables, etc. From there the experience is very similar to any other 
          | Javascript, Node.JS, or CoffeeScript application.
        pre: code.nohighlight
          | borg debug assimilate aws-ca-dev-web01.example.org

        +section('Test Provisioning')
        p
          | There is a 
          code test
          |  mode you can enter with the Borg CLI, which keeps
          | a separate list of servers provisioned in the cloud. This way, while
          | testing, servers you create are still created at your cloud provider--as
          | not to differ from the production environment hardware--but they
          | have a "test-" prefix to set them apart.
        p
          | For example:
        pre: code.nohighlight
          | borg test assimilate aws-ca-dev-web01.example.org
        p
          | While in test mode, you can perform bulk operations such as
          | provisioning every server from your dev environment to see
          | if recent script modifications broke anything.
        pre: code.nohighlight
          | borg test assimilate aws-ca-dev
        p
          | The fourth argument is matching on regular expression.
        p
          | For more information, see:
        pre: code.nohighlight
          | borg help test

        +section('Integration Testing')
        p
          strong(style="color:#999") NOTICE:
          |  This feature is currently in development.
        p
          | A feature using 
          a(href="http://mochajs.org/") Mocha
          |  is planned to run tests in CoffeeScript that are able to
          | execute commands for testing purposes.
          | For example, it might be useful if, after a new machine is cooked,
          | Borg were able to automatically connect to one or more of its peer servers
          | as defined in 
          code network.coffee
          |  and perform a command 
          code nc -vz s &lt;public_ip&gt; &lt;some_port&gt;
          |  in order to determine if important ports were open to them.
        p
          | This type of test would essentially be attempting to reproduce, from the
          | end-user's perspective, whether or not the assimilation resulted
          | in a working service. You can imagine the output would look something
          | like:
        pre: code.nohighlight
          | user@host: ~/project$ borg checkup aws-ca-dev-web01.example.org
          | test: web:
          br
          span(style="color:lime") &#x2714;
          |  web01 was able to connect to redis01 on tcp/6379
          br
          span(style="color:red") &#x2717;
          |  web02 was NOT able to connect to redis01 on tcp/6379
          |    
          span(style="color:red")
            | nc: getaddrinfo: Name or service not known
          | 
          | 
          | 2 test(s) run in 204ms. 1 passed, 1 failed.

        +section('Jobs')
        p
          strong(style="color:#999") NOTICE:
          |  This feature is currently in development.
        p
          | Jobs are essentially partial scripts, which are invoked from 
          | the command-line and perform specific
          | actions of a periodic nature on a remote server.
          | For example, it could
          | restart a service, or perform a software deployment, or
          | truncate logs, or any other routine or mundane task.
        p
          | Jobs are located in 
          code scripts/jobs/*.coffee
          | , which have the benefit of being distributed with
          | and utilizing all the accompanying resources. For example, tasks
          | related to the maintenance of a Percona server, such as peforming
          | a backup snapshot, could be distributed along with the
          code: a(href="https://github.com/borg-scripts/percona") percona
          |  resource which installs the service.




        +chapter('Common Resources')
        p
          | There is a third-party submodule that comes with every new 
          code borg init
          |  and that is the borg-scripts/resources repository. It holds the 
          | most basic functions you would expect to use in any project.
        p
          | Notice that these are kept very light-weight. The list is 
          | short but they do a lot by themselves. The preference though is 
          | very biased toward bash scripting muscle. In the author’s 
          | opinion, it makes more sense for three reasons:
        ol
          li
            | Someone not familiar with borg but who is familiar with bash 
            | could more readily read / QA a borg script and copy/paste from 
            | it to achieve the same outcome.
          li
            | Typically the process for making a new script involves first 
            | making the server manually, which results in a bash history 
            | which is used as a template for the devops script. It saves 
            | time to be able to simply paste the bash history into Borg, 
            | rather than have to translate it to yet another domain 
            | specific language (DSL), and back out to bash when 
            | debugging/troubleshooting.
          li
            | Well-written bash script tends to be terse and powerful, 
            | resulting in far less boilerplate and complexity than the 
            | equivalent heavy resource.
          p
            | Also notice that at the moment they’re all targeting Ubuntu
            | server exclusively. Although its half-expected that resources 
            | will all be converted to an OS-agnostic version in the future, 
            | the author hasn’t had any immediate need for it, yet. Expect 
            | it to be added sooner if someone will volunteer the pull request.

        +section('@execute()')
        p
          | Execute shell command(s) on remote host. Perhaps the most used of
          | all resources.
        p: strong Example:
        pre: code.coffee
          | @then @execute "echo --no-rdoc --no-ri | sudo tee /etc/gemrc"
        p: strong Options:
        ul
          li
            strong sudo:
            |  (Optional): If 
            code true
            | , command will be prefixed with the string 
            code sudo
            | . If 
            code false
            | , no prefix is added. If typeof string, prefix will be
            code sudo -u\#{string}
            | . This option can be useful when you want to sudo
            | a resource that depends on other resources. In that
            | case, they all support this option, and forward the
            | option recursively. But sometimes when piping is
            | involved, its easier to just define sudo in the
            | command yourself and omit this option.
            | Default is 
            code false
            | .
            br
            br
          li
            strong su:
            |  (Optional): Must a be a string containing a username. Will prefix
            | the command with 
            code sudo su - \#{string}
            | . Alternatively you can also just prefix the command
            | yourself. Default is 
            code null
            |  or no prefix. Mutually exclusive of 
            code sudo:
            | .
            br
            br
          li
            strong retry
            |  (Optional): Integer representing number of times to retry the command
            | if it fails, before giving up and 
            code @die()
            | ing. Default is 
            code 0
            | .
            br
            br
          li
            strong ignore_errors:
            |  (Optional): Boolean representing whether to 
            code @die()
            |  if failure is encountered. Default is 
            code true
            | .
            br
            br
          li
            strong expect:
            |  (Optional): A kind of assertion for testing the result of the command.
            | If integer, must match the exit code. If RegExp, must match the combined
            | stdout and stderr output. If string, must case-sensitive string match 
            | the combined output. Failed matches will subsequently 
            code @die()
            | , while matches continue.
            br
            br
          li
            strong test:
            |  (Optional): A callback Function of signature 
            code ({code, out}) =>
            |  where 
            code code
            |  is the exit code, and 
            code out
            |  is the combined stdout and stderr output string.
            | Can be used as an alternative to 
            code expect:
            |  to define your own assertions, or to parse data
            | from the output, or to transform
            | the 
            code @execute()
            |  resource into a kind of asynchronous 
            code if
            |  statement alternative, as in the following example:
            pre: code.coffee
              | @then @execute "date", test: ({out}) =>
              |   if null isnt out.match /Sep/
              |     @then @log "Yay, a birthday month!"
              |   else
              |     @then @log "Boo."
            strong(style="color:#999") NOTICE:
            code @execute()
            | internally wraps 
            code @inject_flow()
            |  before calling our 
            code test:
            |  callback function.
            br
            br









        +section('@package_update()')
        +section('@install()')
        +section('@uninstall()')
        +section('@directory()')
        +section('@chown()')
        +section('@chmod()')
        +section('@template()')
        +section('@upload()')
        +section('@download()')
        +section('@link()')
        +section('@remote_file_exists()')
        +section('@append_line_to_file()')
        +section('@replace_line_in_file()')
        +section('@user()')
        +section('@group()')
        +section('@deploy()')
        +section('@reboot()')

        +chapter('Third-Party Resources')
        pre: code
          | borg install
          | borg update
        p
          | The documentation for resources can be found in their individual repos.
        p
          | For a listing of available repos, see:
          br
          a(href="https://github.com/borg-scripts") https://github.com/borg-scripts


        +chapter('Contributing')
        p Your contributions are welcome via Github.com.

        +section('Issuing a Pull Request')
        ol
          li
            p
              | Fork and clone
            ul
              li
                | Main sources:
                br
                a(href='https://github.com/mikesmullin/borg') https://github.com/mikesmullin/borg
                br
                br
              li
                | Documentation:
                br
                a(href='https://github.com/mikesmullin/borg-docs') https://github.com/mikesmullin/borg-docs
          li Edit to heart&rsquo;s content
          li
            p Publish to your fork:
            pre: code git commit && git push
          li Issue pull request to official repo, and we will review and approve or provide feedback.

    aside
      .wrapper
        .content
          h3 Chapters
          ol
            each chapter in chapters
              li
                a(href="##{chapter.name.dasherize()}")=chapter.name
                ul
                  each section in chapter.sections
                    li: a(href="##{section.dasherize()}")=section

    footer
      .wrapper
        .left
          p
            | This documentation is licensed 
            a(href='http://creativecommons.org/licenses/by-sa/3.0/') Creative Commons Attribution-Share Alike 3.0
          p
            | "Borg" is a service mark of 
            a(href="http://smullindesign.com") Smullin Design
            | .
        .right
          a(href="#top") Back to top &uarr;
        .clear
